!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Joe Dinius | Celebrity Lookalike Project Writeup</title>
  <meta name="description" content="Project/Blog of Joe Dinius, Ph.D. Based on [*folio](https://github.com/bogoli/-folio) design.
">

  <link rel="shortcut icon" href="https://jwdinius.github.io/assets/img/favicon.ico">

  <link rel="stylesheet" href="https://jwdinius.github.io/assets/css/main.css">
  <link rel="canonical" href="https://jwdinius.github.io/blog/2020/lookalike/">
  
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    
    <span class="site-title">
        
        <strong>Joe</strong> Dinius
    </span>
    

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

      <div class="trigger">
        <!-- About -->
        <a class="page-link" href="https://jwdinius.github.io/">about</a>

        <!-- Blog -->
        <a class="page-link" href="https://jwdinius.github.io/blog/">blog</a>

        <!-- Pages -->
        
          
        
          
        
          
            <a class="page-link" href="https://jwdinius.github.io/learning/">learning</a>
          
        
          
        
          
            <a class="page-link" href="https://jwdinius.github.io/projects/">portfolio</a>
          
        
          
            <a class="page-link" href="https://jwdinius.github.io/publications/">publications</a>
          
        
          
        
          
        
          
        

        <!-- CV link -->
        <a class="page-link" href="https://jwdinius.github.io/assets/pdf/resumeDiniusTargeted.pdf">resume</a>

      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Celebrity Lookalike Project Writeup</h1>
    <p class="post-meta">November 8, 2020</p>
  </header>

  <article class="post-content">
    <h1 id="introduction">Introduction</h1>
<p>I am currently enrolled in the OpenCV course “Computer Vision II: Applications (C++)”.  For the second project, I had to create an application that would detect faces in a test image and then find the celebrities (from a provided dataset) whose faces <em>most closely</em> resemble those found in the test image.  I put the phrase “most closely” in italics because I will discuss a few different approaches to finding the best match.  To give a pictorial expression of the project’s objective, the course moderators provided the following expected output for two provided test images:</p>

<p><img src="/assets/img/lookalike/Kazam_screenshot_00000.png" alt="expected-output" /></p>

<p><em>Note: the celebrity lookalike found for the top test image is displayed as Selena, however the lookalike image actually displayed is Selena Gomez.  In the provided dataset, there are folders for both Selena and Selena Gomez, who are in fact two different people, but all images in both folders are for Selena Gomez.</em></p>

<p>In this blog post, I present a formal writeup of my solution addressing requirements of the project.  Where appropriate, I will provide source code snippets highlighting important aspects of my approach.</p>

<h1 id="writeup">Writeup</h1>

<h2 id="objective">Objective</h2>

<p>I will formally state the objective for the project here:</p>

<blockquote>
  <p>Given a dataset of celebrity images, labeled by name, create a low-dimensional <a href="https://www.quora.com/What-is-descriptor-in-computer-vision#:~:text=In%20computer%20vision%2C%20visual%20descriptors,or%20the%20motion%2C%20among%20others.">descriptor</a> representing the likeness of the face detected in each image.  Using this low-dimensional descriptor, compute a similarity score between faces detected in test images and the celebrities in the dataset.  The celebrity with the highest similarity score is declared the “lookalike” or “doppelganger” to an individual detected in a test image.</p>
</blockquote>

<h2 id="dataset">Dataset</h2>

<p>The course moderators provided a dataset, dubbed “celeb_mini”, that contains ~5 images per celebrity for 1000+ celebrities.  There is significant variation in the dataset across the following factors:</p>

<ul>
  <li>Illumination</li>
  <li>Face pose</li>
  <li>Foreground clutter - <em>some images have copyright data overlaid</em></li>
  <li>Sharpness/clarity of the image - <em>some images are quite blurry</em></li>
</ul>

<h2 id="solution">Solution</h2>

<p>Because I am provided with a dataset for this activity, my solution has two phases: <em>training</em> and <em>testing</em>.  During the training phase, I will find representative and informative descriptors for each image in the training set (i.e. the celeb_mini dataset).  During the testing phase, I will apply the learned descriptor model (a function of the input image) to a test image and then find the most similar images in the training set with respect to the learned descriptor.</p>

<p>The solution is constructed in C++, and the primary APIs used in my solution are:</p>

<ul>
  <li><a href="https://opencv.org/opencv-4-1/">OpenCV</a> - used for basic image loading/saving and image processing</li>
  <li><a href="http://dlib.net">dlib</a> - used for linear algebra operations (length, linear systems solvers, and matrix processing), face detection, and for deep neural network inference</li>
  <li><a href="https://matplotlib-cpp.readthedocs.io/en/latest/index.html">matplotlibcpp</a> - for plotting data</li>
</ul>

<p>Before discussing each phase in greater detail, I will present my chosen descriptor model and justification.</p>

<h3 id="descriptor">Descriptor</h3>

<p>Considering the givens and assumptions for this project, I’d like a descriptor with the following qualities:</p>

<ul>
  <li>Low dimensionality (makes comparison simpler and reduces redundancy across dataset)</li>
  <li>Descriptors for images with the same label (i.e. represent the same celebrity) are highly similar (close in some metric sense)</li>
  <li>Descriptors for images with different labels are highly dissimilar (far apart in some metric sense)</li>
</ul>

<p>In the course materials, a solution based on this <a href="http://dlib.net/dnn_metric_learning_on_images_ex.cpp.html">representative example</a> is presented that addresses all three points above using a deep learning-based approach.  The solution uses a backbone architecture based on a <a href="https://arxiv.org/pdf/1512.03385.pdf">ResNet</a> pre-trained using <a href="https://towardsdatascience.com/metric-learning-loss-functions-5b67b3da99a5">metric loss</a> to create a 128-dimensional descriptor of each input image.  To avoid unnecessary effort in retraining the backbone network, I first wanted to see the performance on the assigned task (i.e. finding the correct lookalike for each of the two test images discussed in the Introduction section of this page) using the pre-trained network.</p>

<p>For the purpose of this project, this approach was found to be sufficient.  In the Discussion section below, I will address deficiencies of using the pre-trained approach when considering use-cases outside of the defined boundaries for the project.</p>

<h3 id="training">Training</h3>

<p>This phase is not “training” in the typical sense, since a pre-trained network is used; rather it is more about generating descriptors for the images in the dataset using the pre-trained network.  With this in mind, the training process is outlined as follows:</p>

<ul>
  <li>Load training images</li>
  <li>Assign unique integral label to each subfolder in the dataset - <em>images in each subfolder represent the same celebrity</em></li>
  <li>Map each folder to celebrity name - <em>this will be used to assign celebrity name at the end of the testing process</em></li>
  <li>Load pre-trained model weights and biases for computing the descriptors</li>
  <li>for each image in the training image set
    <ul>
      <li>detect faces in image</li>
      <li>for each face in detected faces
        <ul>
          <li>detect facial landmarks</li>
          <li>use landmarks to crop facial region from image</li>
          <li>compute descriptor using cropped facial region</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>write celebrity name-to-label map to csv file - <em>this will be used to match test image faces to celebrity likeness during the testing phase</em></li>
  <li>write descriptors, along with labels, to csv file for use during testing phase</li>
</ul>

<p>The codebase for this step was built using materials provided by the course moderators, so I am not willing to share it here.</p>

<h3 id="testing">Testing</h3>

<p>This phase’s primary concern is finding the celebrity that most closely resembles individuals detected in a test image.  The process is outlined as follows:</p>

<ul>
  <li>Load pre-trained model weights and biases (the same as in Training phase)</li>
  <li>Load csv file with celebrity name-to-label mapping</li>
  <li>Load csv file with descriptors and associated labels</li>
  <li>Load test image</li>
  <li>Detect faces in test image</li>
  <li>for each face in detected faces
    <ul>
      <li>detect facial landmarks</li>
      <li>use landmarks to crop facial region from image</li>
      <li>compute descriptor using cropped facial region</li>
      <li><em>find most similar celebrity using loaded descriptors</em></li>
    </ul>
  </li>
</ul>

<p>The steps in the loop defined above should look familiar:  <em>they are the same as those used in the Training phase, with the addition of the matching step.</em>  The majority of original work that I did for this project was concerned with the calculation of a similarity metric, so I will focus the discussion around these points.</p>

<p>There are two metrics I used for computing similarity.  The first is a simple, nearest-neighbor approach based on the <a href="https://en.wikipedia.org/wiki/Euclidean_distance#:~:text=In%20mathematics%2C%20the%20Euclidean%20distance,occasionally%20called%20the%20Pythagorean%20distance.">Euclidean distance</a> between descriptor vectors.  The second uses <a href="https://en.wikipedia.org/wiki/Mahalanobis_distance">Mahalanobis distance</a>, which is a distance measure that is normalized by the covariance over samples from the training set with common label.  I will now discuss these two approaches separately.</p>

<h4 id="euclidean-distance">Euclidean distance</h4>

<p>Euclidean distance is really easy to interpret:  <em>if I look at the descriptor vectors as embeddings in a 128D vector space, then similar vectors are ones whose tails are close to one another in the normal linear sense</em>.  In the context of the problem at-hand, the most similar celebrity to a person detected in a test image will have descriptor with shortest length to the descriptor representing the person detected in the test image.</p>

<p>The code to identify the top matches using a Euclidean distance metric is:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**!
 * findKNearestNeighbors
 *
 * given an input descriptor and database of labeled descriptors, find the
 * top K best matches based using a Euclidean distance metric
 *
 */</span>
<span class="kt">bool</span> <span class="nf">findKNearestNeighbors</span><span class="p">(</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">faceDescriptorQuery</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">faceDescriptors</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">faceLabels</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matches</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// check that input vector sizes match, mark failure and exit if they don't</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">faceLabels</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">faceDescriptors</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size mismatch.  Exiting"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// loop over all descriptors and compute Euclidean distance with query descriptor</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">faceDescriptors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// compute distance between descriptors v1 and v2:</span>
    <span class="c1">// d(v1, v2) = std::sqrt((v1-v2)^T * (v1-v2));</span>
    <span class="c1">// - this is implemented in dlib with the `length` function</span>
    <span class="kt">double</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">dlib</span><span class="o">::</span><span class="n">length</span><span class="p">(</span><span class="n">faceDescriptorQuery</span> <span class="o">-</span> <span class="n">faceDescriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="c1">// check if a distance for this label has already been determined</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">neighbors</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">neighbors</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
          <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">faceLabels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">neighbors</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// if there has already been a distance found for this label, check if the current distance is less</span>
      <span class="c1">// than the one previously computed</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// if the current distance is less than the one previously recorded for the label, update it</span>
        <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// this is the first time encountering this label, so add the (label, distance) pair to neighbors</span>
      <span class="n">neighbors</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">faceLabels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">distance</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// do the sort (closest to -&gt; furthest away)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">neighbors</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">neighbors</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
      <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">){</span> <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span>
    
  <span class="c1">// get k closest</span>
  <span class="n">matches</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">neighbors</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">k</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">matches</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code is quite simple.  I loop over all of the descriptors in the database and evaluate the closest distance per-label for all descriptors.  I then sort the output from this stage, with the closest matches first, and return a user-specified number of the best matches (see <code class="language-plaintext highlighter-rouge">k</code> in the function signature for <code class="language-plaintext highlighter-rouge">findKNearestNeighbors</code> above).</p>

<h4 id="mahalanobis-distance">Mahalanobis distance</h4>

<p>Because we have a few representative samples for each label, the Mahalanobis distance metric provides a way evaluating a statistically-relevant measure of closeness conditioned on the available data.  The process for computing the Mahalanobis distance for a test image is as follows:</p>

<ul>
  <li>Compute mean and variance of descriptor vectors over each label - <em>one time, during initialization</em></li>
  <li>Use mean and variance over label descriptor vectors to find the label with smallest Mahalanobis distance to the test image descriptor</li>
</ul>

<p><em>Note: the fundamental assumption of this approach is that the training images for each celebrity are sampled from a normal distribution.  Whether or not this is a valid assumption across the entirety of the dataset was not evaluated as part of this project.  I just wanted to try out this approach and see how it compares to the Euclidean distance approach.</em></p>

<p>During initialization, the mean and variance of the set of descriptors for each label is computed using the code snippet below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**!
 * computeStatsPerLabel
 *
 * given a set of labels and associated descriptors, FOR EACH LABEL i: compute the mean and covariance of descriptor vectors that have
 * label i
 */</span>
<span class="kt">bool</span> <span class="nf">computeStatsPerLabel</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">faceLabels</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">faceDescriptors</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;&amp;</span> <span class="n">meanLabeledDescriptors</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;&amp;</span> <span class="n">covarianceLabeledDescriptors</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// check that input vector sizes match, mark failure and exit if they don't</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">faceLabels</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">faceDescriptors</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size mismatch.  Exiting"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// empty containers</span>
  <span class="n">meanLabeledDescriptors</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">covarianceLabeledDescriptors</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

  <span class="c1">// setup associative container for labeled descriptors and populate it</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;&gt;</span> <span class="n">labeledDescriptors</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">faceLabels</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if we haven't seen any descriptors for the present label, initialize</span>
    <span class="c1">// the vector for this label</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">labeledDescriptors</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">faceLabels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">labeledDescriptors</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">labeledDescriptors</span><span class="p">[</span><span class="n">faceLabels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">faceDescriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// if we have already have descriptors for this label, append the current descriptor</span>
      <span class="n">labeledDescriptors</span><span class="p">[</span><span class="n">faceLabels</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">faceDescriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// for each key-value pair in the labeledDescriptors container</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">pr</span> <span class="o">:</span> <span class="n">labeledDescriptors</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// compute mean and covariance</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">descriptors</span> <span class="o">=</span> <span class="n">pr</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">;</span>
    <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">covariance</span><span class="p">;</span>
    <span class="n">computeNormalParameters</span><span class="p">(</span><span class="n">descriptors</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">label</span> <span class="o">=</span> <span class="n">pr</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="c1">// add to output data containers</span>
    <span class="n">meanLabeledDescriptors</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span><span class="p">;</span>
    <span class="n">covarianceLabeledDescriptors</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">covariance</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// mark successful execution</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>with the relevant mean and variance computations being done by the <code class="language-plaintext highlighter-rouge">computeNormalParameters</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**!
 * computeNormalParameters
 *
 * given a set of input descriptor vectors, compute the mean and covariance of that set
 *
 */</span>
<span class="kt">void</span> <span class="nf">computeNormalParameters</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vecs</span><span class="p">,</span>
    <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&amp;</span> <span class="n">covariance</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// if the input vector is empty, just exit</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">vecs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Nothing to do"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// shorthand for vector size</span>
  <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">N</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">// compute the mean = sum(v in vecs) / N</span>
  <span class="n">mean</span><span class="p">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nr</span><span class="p">());</span>
  <span class="n">dlib</span><span class="o">::</span><span class="n">set_all_elements</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">v</span> <span class="o">:</span> <span class="n">vecs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mean</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">mean</span> <span class="o">/=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>

  <span class="c1">// compute the covariance = sum( (v-mean)*(v-mean)^T ) / N</span>
  <span class="n">covariance</span><span class="p">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">mean</span><span class="p">.</span><span class="n">nr</span><span class="p">(),</span> <span class="n">mean</span><span class="p">.</span><span class="n">nr</span><span class="p">());</span>
  <span class="n">dlib</span><span class="o">::</span><span class="n">set_all_elements</span><span class="p">(</span><span class="n">covariance</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">v</span> <span class="o">:</span> <span class="n">vecs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">covariance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">*</span> <span class="n">dlib</span><span class="o">::</span><span class="n">trans</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mean</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">covariance</span> <span class="o">/=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With the mean and variance for each set of descriptors available, I can find the Mahalanobis distance between a test image’s descriptor and that set’s mean descriptor; see <code class="language-plaintext highlighter-rouge">findKMostLikely</code> below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define REGULARIZATION 1e-8  // covariance += REGULARIZATION*Identity - this is necessary to stabilize the matrix decomposition used for the Mahalanobis distance calculation
</span><span class="cm">/**!
 * findKMostLikely
 *
 * given an input descriptor and mean and covariance for each label's descriptor vectors, find the
 * top K best matches based using a Mahalanobis distance metric
 *
 */</span>
<span class="kt">bool</span> <span class="nf">findKMostLikely</span><span class="p">(</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">faceDescriptorQuery</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">meanLabeledDescriptors</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">covarianceLabeledDescriptors</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matches</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// check that input vector sizes match, mark failure and exit if they don't</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">meanLabeledDescriptors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">covarianceLabeledDescriptors</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size mismatch.  Exiting."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// loop over all sets of mean/covariance pairs</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">mahalanobisVec</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">meanLabeledDescriptors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">covariance</span> <span class="o">=</span> <span class="n">covarianceLabeledDescriptors</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="c1">// add some noise to the primary diagonal of the covariance matrix to regularize it</span>
    <span class="c1">// and improve the numerical stability of the subsequent solver</span>
    <span class="k">auto</span> <span class="n">transCov</span> <span class="o">=</span> <span class="n">covariance</span> <span class="o">+</span> <span class="n">REGULARIZATION</span> <span class="o">*</span> <span class="n">dlib</span><span class="o">::</span><span class="n">identity_matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">covariance</span><span class="p">.</span><span class="n">nr</span><span class="p">());</span>
    <span class="k">auto</span> <span class="n">luDecomp</span> <span class="o">=</span> <span class="n">dlib</span><span class="o">::</span><span class="n">lu_decomposition</span><span class="o">&lt;</span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">transCov</span><span class="p">);</span>
    
    <span class="c1">// check if the object indicates a system that is not full-rank</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">luDecomp</span><span class="p">.</span><span class="n">is_singular</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// there's nothing further to be done if the starting problem is singular, so go</span>
      <span class="c1">// to the next loop iteration</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Starting matrix is singular"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// compute residual of query descriptor with the current mean</span>
    <span class="k">auto</span> <span class="n">residual</span> <span class="o">=</span> <span class="n">faceDescriptorQuery</span> <span class="o">-</span> <span class="n">meanLabeledDescriptors</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    
    <span class="c1">// solve the linear system residual = S*y to get a more numerically-stable</span>
    <span class="c1">// representation of S^{-1}*residual in the Mahalanobis calculation </span>
    <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">luDecomp</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">residual</span><span class="p">);</span>

    <span class="c1">// compute Mahalanobis distance given mean, m, and covariance, S:</span>
    <span class="c1">// d(v1, m, S) = std::sqrt((v1-m)^T * S^{-1} * (v1-m));</span>
    <span class="kt">double</span> <span class="n">mahalanobisDistance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dlib</span><span class="o">::</span><span class="n">trans</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span>

    <span class="c1">// add result to full vector</span>
    <span class="n">mahalanobisVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mahalanobisDistance</span><span class="p">));</span>
  <span class="p">}</span>
  
  <span class="c1">// do the sort (smallest mahalanobis distance -&gt; largest)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">mahalanobisVec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">mahalanobisVec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
      <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">){</span> <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span>
  
  <span class="c1">// get k matches that have smallest mahalanobis distance</span>
  <span class="n">matches</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">mahalanobisVec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">k</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">matches</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="results">Results</h2>

<p>Because I was curious about not just the best identified match, I used my approach to find the best 5 matches for both of the two test images referenced in the Introduction section above.  Without further ado, the results are presented below.</p>

<h3 id="image-1">Image 1:</h3>

<h4 id="euclidean-distance-1">Euclidean distance</h4>

<p><img src="/assets/img/lookalike/sofia-solares_fid0_ed.jpg" alt="ed-sofia" /></p>

<h4 id="mahalanobis-distance-1">Mahalanobis distance</h4>

<p><img src="/assets/img/lookalike/sofia-solares_fid0_md.jpg" alt="md-sofia" /></p>

<h3 id="image-2">Image 2:</h3>

<h4 id="euclidean-distance-2">Euclidean distance</h4>

<p><img src="/assets/img/lookalike/shashikant-pedwal_fid0_ed.jpg" alt="ed-shashikant" /></p>

<h4 id="mahalanobis-distance-2">Mahalanobis distance</h4>

<p><img src="/assets/img/lookalike/shashikant-pedwal_fid0_md.jpg" alt="md-shashikant" /></p>

<h2 id="discussion">Discussion</h2>

<h3 id="performance-on-test-images">Performance on test images</h3>

<p>The discussion here will be brief, since the expected outcome of the project has been successfully demonstrated in the plots from the Results section above; <em>the best match identified for each test image provided matches expectation</em>.  What I would like to highlight is the fact that the two approaches lead to similar results for the top, i.e. best, matches.  In fact, based on similarity of results achieved for both methods, and the fact that the Euclidean distance approach was much easier to implement, I would focus further efforts with this particular method towards using the Euclidean distance for means of evaluating similarity.</p>

<p>One thing of note is that Matches 1 and 2 for Image 1 claim to represent two different celebrities, Selena and Selena Gomez, however the images representing Selena are, in fact, pictures of Selena Gomez.  Since I didn’t have to train the model, this inconsistency in labeling isn’t a big deal, but if I were to refine the model by retraining on the celeb_mini dataset provided, I would merge the two separate folders into one.  Moreover, I’d do a deeper dive into the dataset itself to make sure there were no other inconsistencies present.</p>

<h3 id="performance-on-other-images">Performance on other images</h3>

<p>I was curious about what the approach would say about who the celebrity doppelgangers are for my wife and I and, as a follow-up, find out whether or not such predictions be common across different images (with different lighting, background, glasses/no-glasses, etc…).  The results are shown below.</p>

<h4 id="image-3-my-wife-and-i-at-a-restaurant">Image 3: My wife and I at a restaurant</h4>

<p><img src="/assets/img/lookalike/IMG-0580_fid0_ed.jpg" alt="ed-joe-rest" /></p>

<p><img src="/assets/img/lookalike/IMG-0580_fid0_md.jpg" alt="md-joe-rest" /></p>

<p><img src="/assets/img/lookalike/IMG-0580_fid1_ed.jpg" alt="ed-jess-rest" /></p>

<p><img src="/assets/img/lookalike/IMG-0580_fid1_md.jpg" alt="md-jess-rest" /></p>

<p><em>Note: to poke at the issue of data labeling yet again: the image shown for Match 4 is, in fact, an image of Kathy Bates,</em> not <em>Mary Kay Place.</em></p>

<h4 id="image-4-my-wife-and-i-near-a-lake-at-dusk">Image 4: My wife and I near a lake at dusk</h4>

<p><img src="/assets/img/lookalike/20190615-190740_fid0_ed.jpg" alt="ed-joe-lake" /></p>

<p><img src="/assets/img/lookalike/20190615-190740_fid0_md.jpg" alt="md-joe-lake" /></p>

<p><img src="/assets/img/lookalike/20190615-190740_fid1_ed.jpg" alt="ed-jess-lake" /></p>

<p><img src="/assets/img/lookalike/20190615-190740_fid1_md.jpg" alt="md-jess-lake" /></p>

<h2 id="final-remarks">Final Remarks</h2>

<p>Although there are some common matches between the two images for both my wife and myself, the top matches are different.  Therefore it is expected that this approach would need considerable work to generalize to new images.  To increase generalizability of the approach, I would try out the following approaches:</p>

<ul>
  <li><em>Gather additional data</em>.  This is always the best approach if data is not difficult to gather (in this case, it wouldn’t be)</li>
  <li><em>Scrub the data and clean labels</em>.  In my limited investigations with the data, I found a few bogus examples (in terms of incorrect labeling), as well as some blurry, low-quality images.</li>
  <li><em>Retrain the model</em>. This will definitely improve inter-class separation (w.r.t the metric loss function) among the classes present in the input dataset</li>
</ul>

<p>I had a lot of fun working this project.  After finishing, I have come to really appreciate the dlib C++ API; it provides <em>so</em> much functionality in one project: linear algebra, machine learning, multithreading, optimization, … the list goes on-and-on.  I am really looking forward to working more with this library in future projects.</p>

<p>I know that I’ve only been able to highlight portions of the project above, but I’m happy to discuss the other aspects of the project over email or whatever (see contact info at the bottom of <a href="https://jwdinius.github.io">here</a>).</p>

<p>I hope that you got something out of this post.  Thanks for reading!</p>

  </article>

  
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname  = 'https-jwdinius-github-io';
      var disqus_identifier = '/blog/2020/lookalike';
      var disqus_title      = "Celebrity Lookalike Project Writeup";
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  

</div>

      </div>
    </div>

    <footer>

  <div class="wrapper">
    &copy; Copyright 2023 Joe Dinius.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    
  </div>

</footer>


    <!-- Load jQuery -->
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>

<!-- Load Common JS -->
<script src="https://jwdinius.github.io/assets/js/common.js"></script>





<!-- Include custom icon fonts -->
<link rel="stylesheet" href="https://jwdinius.github.io/assets/css/fontawesome-all.min.css">
<link rel="stylesheet" href="https://jwdinius.github.io/assets/css/academicons.min.css">

<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-XXXXXXXXX', 'auto');
ga('send', 'pageview');
</script>


  </body>

</html>
